From ba03fc39341c4df2d6dce00b03bf42f86f6d54a3 Mon Sep 17 00:00:00 2001
From: Xiaoyi Shi <ashi009@gmail.com>
Date: Wed, 18 Jul 2018 18:12:55 +0800
Subject: [PATCH] move http header handling code from stackdriver/propagation
 to trace/propagation

---
 exporter/stackdriver/propagation/http.go | 58 ++--------------------------
 plugin/ocgrpc/trace_common.go            | 51 ++++++++++++++----------
 trace/propagation/propagation.go         | 66 ++++++++++++++++++++++++++++++++
 3 files changed, 99 insertions(+), 76 deletions(-)

diff --git a/exporter/stackdriver/propagation/http.go b/exporter/stackdriver/propagation/http.go
index 7cc02a1..d37a6d1 100644
--- a/exporter/stackdriver/propagation/http.go
+++ b/exporter/stackdriver/propagation/http.go
@@ -17,21 +17,13 @@
 package propagation // import "go.opencensus.io/exporter/stackdriver/propagation"
 
 import (
-	"encoding/binary"
-	"encoding/hex"
-	"fmt"
 	"net/http"
-	"strconv"
-	"strings"
 
 	"go.opencensus.io/trace"
 	"go.opencensus.io/trace/propagation"
 )
 
-const (
-	httpHeaderMaxSize = 200
-	httpHeader        = `X-Cloud-Trace-Context`
-)
+const httpHeader = `X-Cloud-Trace-Context`
 
 var _ propagation.HTTPFormat = (*HTTPFormat)(nil)
 
@@ -41,54 +33,10 @@ type HTTPFormat struct{}
 
 // SpanContextFromRequest extracts a Stackdriver Trace span context from incoming requests.
 func (f *HTTPFormat) SpanContextFromRequest(req *http.Request) (sc trace.SpanContext, ok bool) {
-	h := req.Header.Get(httpHeader)
-	// See https://cloud.google.com/trace/docs/faq for the header HTTPFormat.
-	// Return if the header is empty or missing, or if the header is unreasonably
-	// large, to avoid making unnecessary copies of a large string.
-	if h == "" || len(h) > httpHeaderMaxSize {
-		return trace.SpanContext{}, false
-	}
-
-	// Parse the trace id field.
-	slash := strings.Index(h, `/`)
-	if slash == -1 {
-		return trace.SpanContext{}, false
-	}
-	tid, h := h[:slash], h[slash+1:]
-
-	buf, err := hex.DecodeString(tid)
-	if err != nil {
-		return trace.SpanContext{}, false
-	}
-	copy(sc.TraceID[:], buf)
-
-	// Parse the span id field.
-	spanstr := h
-	semicolon := strings.Index(h, `;`)
-	if semicolon != -1 {
-		spanstr, h = h[:semicolon], h[semicolon+1:]
-	}
-	sid, err := strconv.ParseUint(spanstr, 10, 64)
-	if err != nil {
-		return trace.SpanContext{}, false
-	}
-	binary.BigEndian.PutUint64(sc.SpanID[:], sid)
-
-	// Parse the options field, options field is optional.
-	if !strings.HasPrefix(h, "o=") {
-		return sc, true
-	}
-	o, err := strconv.ParseUint(h[2:], 10, 64)
-	if err != nil {
-		return trace.SpanContext{}, false
-	}
-	sc.TraceOptions = trace.TraceOptions(o)
-	return sc, true
+	return propagation.FromHTTPHeader(req.Header.Get(httpHeader))
 }
 
 // SpanContextToRequest modifies the given request to include a Stackdriver Trace header.
 func (f *HTTPFormat) SpanContextToRequest(sc trace.SpanContext, req *http.Request) {
-	sid := binary.BigEndian.Uint64(sc.SpanID[:])
-	header := fmt.Sprintf("%s/%d;o=%d", hex.EncodeToString(sc.TraceID[:]), sid, int64(sc.TraceOptions))
-	req.Header.Set(httpHeader, header)
+	req.Header.Set(httpHeader, propagation.HTTPHeader(sc))
 }
diff --git a/plugin/ocgrpc/trace_common.go b/plugin/ocgrpc/trace_common.go
index 720f381..73365ec 100644
--- a/plugin/ocgrpc/trace_common.go
+++ b/plugin/ocgrpc/trace_common.go
@@ -27,7 +27,25 @@ import (
 	"google.golang.org/grpc/status"
 )
 
-const traceContextKey = "grpc-trace-bin"
+const (
+	traceContextKey     = "grpc-trace-bin"
+	httpTraceContextKey = "x-cloud-trace-context"
+)
+
+func parentSpanFromContext(ctx context.Context) (sc trace.SpanContext, ok bool) {
+	md, _ := metadata.FromIncomingContext(ctx)
+	if traceContext := md[httpTraceContextKey]; len(traceContext) > 0 {
+		return propagation.FromHTTPHeader(traceContext[0])
+	}
+	if traceContext := md[traceContextKey]; len(traceContext) > 0 {
+		// Metadata with keys ending in -bin are actually binary. They are base64
+		// encoded before being put on the wire, see:
+		// https://github.com/grpc/grpc-go/blob/08d6261/Documentation/grpc-metadata.md#storing-binary-data-in-metadata
+		traceContextBinary := []byte(traceContext[0])
+		return propagation.FromBinary(traceContextBinary)
+	}
+	return trace.SpanContext{}, false
+}
 
 // TagRPC creates a new trace span for the client side of the RPC.
 //
@@ -40,7 +58,10 @@ func (c *ClientHandler) traceTagRPC(ctx context.Context, rti *stats.RPCTagInfo)
 		trace.WithSampler(c.StartOptions.Sampler),
 		trace.WithSpanKind(trace.SpanKindClient)) // span is ended by traceHandleRPC
 	traceContextBinary := propagation.Binary(span.SpanContext())
-	return metadata.AppendToOutgoingContext(ctx, traceContextKey, string(traceContextBinary))
+	return metadata.AppendToOutgoingContext(ctx,
+		traceContextKey, string(traceContextBinary),
+		httpTraceContextKey, propagation.HTTPHeader(span.SpanContext()),
+	)
 }
 
 // TagRPC creates a new trace span for the server side of the RPC.
@@ -50,27 +71,15 @@ func (c *ClientHandler) traceTagRPC(ctx context.Context, rti *stats.RPCTagInfo)
 //
 // It returns ctx, with the new trace span added.
 func (s *ServerHandler) traceTagRPC(ctx context.Context, rti *stats.RPCTagInfo) context.Context {
-	md, _ := metadata.FromIncomingContext(ctx)
 	name := strings.TrimPrefix(rti.FullMethodName, "/")
 	name = strings.Replace(name, "/", ".", -1)
-	traceContext := md[traceContextKey]
-	var (
-		parent     trace.SpanContext
-		haveParent bool
-	)
-	if len(traceContext) > 0 {
-		// Metadata with keys ending in -bin are actually binary. They are base64
-		// encoded before being put on the wire, see:
-		// https://github.com/grpc/grpc-go/blob/08d6261/Documentation/grpc-metadata.md#storing-binary-data-in-metadata
-		traceContextBinary := []byte(traceContext[0])
-		parent, haveParent = propagation.FromBinary(traceContextBinary)
-		if haveParent && !s.IsPublicEndpoint {
-			ctx, _ := trace.StartSpanWithRemoteParent(ctx, name, parent,
-				trace.WithSpanKind(trace.SpanKindServer),
-				trace.WithSampler(s.StartOptions.Sampler),
-			)
-			return ctx
-		}
+	parent, haveParent := parentSpanFromContext(ctx)
+	if haveParent && !s.IsPublicEndpoint {
+		ctx, _ := trace.StartSpanWithRemoteParent(ctx, name, parent,
+			trace.WithSpanKind(trace.SpanKindServer),
+			trace.WithSampler(s.StartOptions.Sampler),
+		)
+		return ctx
 	}
 	ctx, span := trace.StartSpan(ctx, name,
 		trace.WithSpanKind(trace.SpanKindServer),
diff --git a/trace/propagation/propagation.go b/trace/propagation/propagation.go
index 1eb190a..278e507 100644
--- a/trace/propagation/propagation.go
+++ b/trace/propagation/propagation.go
@@ -46,11 +46,18 @@ package propagation // import "go.opencensus.io/trace/propagation"
 // trace_options = {1};
 
 import (
+	"encoding/binary"
+	"encoding/hex"
+	"fmt"
 	"net/http"
+	"strconv"
+	"strings"
 
 	"go.opencensus.io/trace"
 )
 
+const httpHeaderMaxSize = 200
+
 // Binary returns the binary format representation of a SpanContext.
 //
 // If sc is the zero value, Binary returns nil.
@@ -92,6 +99,65 @@ func FromBinary(b []byte) (sc trace.SpanContext, ok bool) {
 	return sc, true
 }
 
+// HTTPHeader returns HTTP header format representation of a SpanContext.
+//
+// If sc is the zero value, HTTPHeader returns an empty string.
+func HTTPHeader(sc trace.SpanContext) string {
+	if sc == (trace.SpanContext{}) {
+		return ""
+	}
+	sid := binary.BigEndian.Uint64(sc.SpanID[:])
+	return fmt.Sprintf("%s/%d;o=%d", hex.EncodeToString(sc.TraceID[:]), sid, int64(sc.TraceOptions))
+}
+
+// FromHTTPHeader returns the SpanContext represented by h.
+//
+// If h has is empty, or unreasonably large, FromHTTPHeader returns with
+// ok==false.
+//
+// See https://cloud.google.com/trace/docs/faq for the header HTTPFormat.
+func FromHTTPHeader(h string) (sc trace.SpanContext, ok bool) {
+	if h == "" || len(h) > httpHeaderMaxSize {
+		return trace.SpanContext{}, false
+	}
+
+	// Parse the trace id field.
+	slash := strings.Index(h, `/`)
+	if slash == -1 {
+		return trace.SpanContext{}, false
+	}
+	tid, h := h[:slash], h[slash+1:]
+
+	buf, err := hex.DecodeString(tid)
+	if err != nil {
+		return trace.SpanContext{}, false
+	}
+	copy(sc.TraceID[:], buf)
+
+	// Parse the span id field.
+	spanstr := h
+	semicolon := strings.Index(h, `;`)
+	if semicolon != -1 {
+		spanstr, h = h[:semicolon], h[semicolon+1:]
+	}
+	sid, err := strconv.ParseUint(spanstr, 10, 64)
+	if err != nil {
+		return trace.SpanContext{}, false
+	}
+	binary.BigEndian.PutUint64(sc.SpanID[:], sid)
+
+	// Parse the options field, options field is optional.
+	if !strings.HasPrefix(h, "o=") {
+		return sc, true
+	}
+	o, err := strconv.ParseUint(h[2:], 10, 64)
+	if err != nil {
+		return trace.SpanContext{}, false
+	}
+	sc.TraceOptions = trace.TraceOptions(o)
+	return sc, true
+}
+
 // HTTPFormat implementations propagate span contexts
 // in HTTP requests.
 //
-- 
2.15.2 (Apple Git-101.1)

